{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>In the latest releases of Istio, with support for Ambient mode becoming Generally Available (GA), and with its support for the Kubernetes Gateway API, we are finally at a point where platform engineers can provision, configure and control network traffic in uniform way, and without the overhead of sidecars.</p> <p>It is important to stress that the above term \"network traffic\" implies traffic in all directions: at ingress, at egress, as well as internal \"mesh\" traffic, also known as \"east-west\" traffic. This vision of a single, uniform API to control traffic in all directions is something we at Solo.io have dubbed \"Omni\" (see What is Omni?).</p> <p>This document is a hands-on exploration of configuring ingress, egress, and mesh traffic, in order to see first-hand how this is done. The main objective is to get a sense for how these different activities are performed with a single API, and where the process of configuring and controlling traffic is in many ways the same.</p>"},{"location":"egress/","title":"Configure &amp; Control Egress","text":"<p>Below, we walk through a general example for configuring egress, taken from the documentation.</p>"},{"location":"egress/#provision-a-gateway","title":"Provision a gateway","text":"<p>Just like we did for ingress, we begin by provisioning a Gateway.</p> <p>This time we enlist the help of the Istio CLI, specifically the command <code>istioctl waypoint apply</code>:</p> <pre><code>istioctl waypoint apply --enroll-namespace --name egress-gateway \\\n  --namespace common-infrastructure\n</code></pre> <p>The above command generates a Gateway resource and applies it to the indicated namespace.</p> <p>We can verify this by asking for resources of type Gateway in the <code>common-infrastructure</code> namespace:</p> <pre><code>kubectl get gtw -n common-infrastructure\n</code></pre> <p>The output indicates that we now have two Gateways, though the GatewayClass type is different for each:</p> <pre><code>NAME             CLASS            ADDRESS        PROGRAMMED   AGE\negress-gateway   istio-waypoint   10.43.227.68   True         4h3m\nshared-gateway   istio            192.168.97.2   True         21m\n</code></pre> <p>The other subtle but important point in the above <code>istioctl</code> command is the <code>--enroll-namespace</code> flag:  any services defined in that namespace will be proxied by this egress gateway.</p>"},{"location":"egress/#create-a-serviceentry","title":"Create a ServiceEntry","text":"<p>The <code>ServiceEntry</code> resource is designed to allow Istio to be aware of services that reside outside the mesh.</p> <p>Here is for example a <code>ServiceEntry</code> that communicates to Istio that mesh workloads may call the hostname <code>httpbin.org</code>.</p> <pre><code>---\napiVersion: networking.istio.io/v1\nkind: ServiceEntry\nmetadata:\n  name: httpbin.org\n  namespace: common-infrastructure\nspec:\n  hosts:\n  - httpbin.org\n  ports:\n  - number: 80\n    name: http\n    protocol: HTTP\n    targetPort: 443 # New: send traffic originally for port 80 to port 443\n  resolution: DNS\n</code></pre> <p>In this case, the IP address of the target workload is obtained through DNS resolution.</p> <p>The convention is that clients call <code>httpbin.org</code> using the url <code>http://httpbin.org/</code> on port 80. The ServiceEntry however, specifies a <code>targetPort</code> of 443, indicating that the outbound request to the actual service will be on a different port.</p> <p>Since the <code>ServiceEntry</code> is defined in the <code>common-infrastructure</code> namespace, traffic from clients targeting the host <code>httpbin.org</code> will be routed to the egress gateway. Communication from the client to the gateway will use mutual TLS by virtue of both ends of that communication being a part of the mesh.</p>"},{"location":"egress/#configure-tls-origination","title":"Configure TLS Origination","text":"<p>The egress gateway can then be configured to call <code>httpbin.org</code> over TLS. We use a <code>DestinationRule</code> to capture the traffic policy and associate it with the host:</p> <pre><code>---\napiVersion: networking.istio.io/v1\nkind: DestinationRule\nmetadata:\n  name: httpbin.org-tls\n  namespace: common-infrastructure\nspec:\n  host: httpbin.org\n  trafficPolicy:\n    tls:\n      mode: SIMPLE\n</code></pre> <p>TLS origination is the mirror-opposite of TLS termination, and requires less configuration since with simple TLS, only the server identifies itself to the client.</p>"},{"location":"egress/#test-it","title":"Test it","text":"<p>In one terminal, tail the egress gateway logs:</p> <pre><code>kubectl logs --follow -n common-infrastructure deployments/egress-gateway\n</code></pre> <p>From another terminal, send a request from the <code>curl</code> client to the external endpoint:</p> <pre><code>kubectl exec deploy/curl -- curl -s -v http://httpbin.org/get\n</code></pre> <p>Here is a sample log output (broken into multiple lines for legibility):</p> <pre><code>[2025-06-30T02:48:20.634Z] \"GET /get HTTP/1.1\" 200 - via_upstream - \"-\" 0 255 1477 1477 \"-\" \n  \"curl/8.14.1\" \"c29d1bce-1dcd-4615-a7e6-2e1caa35ce76\" \"httpbin.org\" \n  \"44.207.188.95:443\" inbound-vip|80|http|httpbin.org \n  10.42.0.8:40324 240.240.0.3:80 10.42.0.9:35662 - default\n</code></pre>"},{"location":"egress/#add-an-authorization-policy","title":"Add an Authorization Policy","text":"<p>Routing calls to external endpoints through an egress gateway effectively gives us a Policy Enforcement Point (PEP): we can configure an authorization policy at that egress gateway point to control who is allowed to make what kinds of calls to which endpoints. That is the essence of authorization.</p> <p>Study the following example, an AuthorizationPolicy that allows only HTTP GET-type operations to the external <code>httpbin</code> service's <code>/get</code> endpoint and nothing else:</p> <pre><code>---\napiVersion: security.istio.io/v1\nkind: AuthorizationPolicy\nmetadata:\n  name: httpbin-get-only\n  namespace: common-infrastructure\nspec:\n  targetRefs:\n  - kind: ServiceEntry\n    group: networking.istio.io\n    name: httpbin.org\n  action: ALLOW\n  rules:\n  - to:\n    - operation:\n        methods: [\"GET\"]\n        paths: [\"/get\"]\n</code></pre> <p>Apply the above policy programs the egress gateway to allow only permitted operations.</p> <p>Verify that you are authorized only to call that <code>/get</code> endpoint:</p> <pre><code>kubectl exec deploy/curl -- curl -s http://httpbin.org/get\n</code></pre> <p>Try a different endpoint:</p> <pre><code>kubectl exec deploy/curl -- curl -s http://httpbin.org/json\n</code></pre> <p>The response should indicate that the request was denied:</p> <pre><code>RBAC: access denied\n</code></pre>"},{"location":"egress/#analysis-for-egress","title":"Analysis for Egress","text":"<p>The API we used to configure egress is familiar, the same API we use for ingress and, as you will see, mesh traffic.</p> <p>The resources we used were:</p> <ul> <li> <p>The Kubernetes Gateway API's <code>Gateway</code> resource is used for provisioning the egress Gateway.  We use the same resource to configure Ingress Gateways and Waypoints.  The same API.</p> </li> <li> <p>To control traffic management, we used Istio's <code>ServiceEntry</code> to define the target external endpoint, and <code>DestinationRule</code> to configure how (over simple TLS) we communicate with that destination.</p> </li> <li> <p>Finally, security (authorization, to be precise) was configured using Istio's <code>AuthorizationPolicy</code> resource.</p> </li> </ul> <p>It should be noted that Istio also implicitly configures workload identity and mutual TLS-encrypted traffic within the mesh (no configuration required), as well as basic observability. As we saw in setup, aspects of observability can be further configured with the <code>Telemetry</code> resource.</p> <p>The same basic API is used to configure both ingress and east-west traffic.</p>"},{"location":"ingress/","title":"Configure &amp; Control Ingress","text":"<p>As you review the steps outlined below, observe the general process we follow to provision gateways, configure traffic flows, and overlay authorization policies.</p> <p>The main task is to expose <code>bookinfo</code>'s web UI and API (served by the <code>productpage</code> service) to the internet through an ingress gateway.</p>"},{"location":"ingress/#provision-and-configure-the-gateway","title":"Provision and configure the Gateway","text":"<p>Before we begin, we need to make some design decisions that pertain to our gateway:</p> <ul> <li>The gateway should accept HTTPS traffic.</li> <li>It should redirect HTTP traffic to the HTTPS scheme.</li> <li>The gateway should terminate TLS.</li> </ul> <p>We also have the option to deploy either a dedicated gateway for <code>bookinfo</code>, or a shared gateway that routes ingress traffic on behalf of mulitple APIs and applications that we intend to deploy to our cluster.</p> <p>Let us proceed with a shared gateway, that we decide to deploy to a namespace named <code>common-infrastructure</code>.</p> <p>Create the namespace:</p> <pre><code>kubectl create namespace common-infrastructure\n</code></pre> <p>Make the namespace part of the mesh:</p> <pre><code>kubectl label namespace common-infrastructure istio.io/dataplane-mode=ambient\n</code></pre> <p>Thanks to the Kubernetes Gateway API, we can provision our gateway on demand, by applying the following <code>Gateway</code> resource:</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: shared-gateway\n  namespace: common-infrastructure\nspec:\n  gatewayClassName: istio\n  listeners:\n  - name: http\n    port: 80\n    protocol: HTTP\n    allowedRoutes:\n      namespaces:\n        from: Same\n  - name: bookinfo-https\n    protocol: HTTPS\n    port: 443\n    hostname: bookinfo.example.com\n    tls:\n      mode: Terminate\n      certificateRefs:\n      - name: bookinfo-cert\n    allowedRoutes:\n      namespaces:\n        from: Selector\n        selector:\n          matchLabels:\n            self-serve-ingress: \"true\"\n</code></pre> <p>Let us break down the above configuration; we:</p> <ul> <li>Name the gateway <code>shared-gateway</code>, and place it in the <code>common-infrastructure</code> namespace.</li> <li>Associate the ingress gateway with Istio by specifying the <code>istio</code> gatewayClassName.</li> <li>Expose a listener on port 80 that we intend to configure to redirect traffic to port 443.</li> <li>Expose a listener on port 443, bound to the [ficticious] hostname <code>bookinfo.example.com</code>, configured to terminate TLS.</li> <li>Configure the gateway to allow the binding of routes that reside in namespaces labeled <code>self-serve-ingress</code> with value <code>true</code> (an adhoc convention).</li> </ul> <p>Apply that label to the <code>bookinfo</code> namespace now, since we know we will need to define a route there for directing requests to the <code>productpage</code> service:</p> <pre><code>kubectl label ns bookinfo self-serve-ingress=true\n</code></pre> <p>The generation of the TLS certificate for the hostname <code>bookinfo.example.com</code> and its storage into a kubernetes <code>Secret</code> by the name of <code>bookinfo-cert</code> can be performed using many different tools and methods, and is left as an exercise.</p> <p>I used the <code>step</code> CLI to generate the certificate:</p> <pre><code>step certificate create bookinfo.example.com bookinfo.crt bookinfo.key \\\n  --profile self-signed --subtle --no-password --insecure\n</code></pre> <p>And this command to apply the secret to the cluster:</p> <pre><code>kubectl create secret tls bookinfo-cert -n common-infrastructure \\\n  --cert=bookinfo.crt --key=bookinfo.key\n</code></pre> <p>Applying the <code>Gateway</code> resource to the cluster triggers a number of actions:</p> <ol> <li>A Gateway is provisioned:  Istio will provision an Envoy proxy for the gateway, and program it accordingly, as we just outlined.  You will see a deployment in the <code>common-infrastructure</code> namespace (which begets a ReplicaSet and in turn a Pod).</li> <li>Istio will program the proxy according to the <code>Gateway</code> configuration specification we supplied.</li> <li>A service of type LoadBalancer is created.  For a Kubernetes cluster deployed in the cloud, this implies the creation of an L4-type load balancer with a public static IP address, configured to route requests to the Envoy proxy deployment.  A DNS record should be configured for the hostname pointing to that public IP address.</li> </ol> <p>At this point the Gateway can receive HTTP requests from the internet, but will return a 404, until we configure how we wish the proxy to route those requests.</p>"},{"location":"ingress/#controlling-routing","title":"Controlling routing","text":"<p>The HTTPRoute resource to expose the <code>productpage</code> service's endpoints is bundled with Istio's <code>bookinfo</code> sample application.  Here it is, adjusted to this specific context:</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: bookinfo-route\n  namespace: bookinfo\nspec:\n  hostnames:\n  - bookinfo.example.com\n  parentRefs:\n  - name: shared-gateway\n    namespace: common-infrastructure\n    sectionName: bookinfo-https\n  rules:\n  - matches:\n    - path:\n        type: Exact\n        value: /productpage\n    - path:\n        type: PathPrefix\n        value: /static\n    - path:\n        type: Exact\n        value: /login\n    - path:\n        type: Exact\n        value: /logout\n    - path:\n        type: PathPrefix\n        value: /api/v1/products\n    backendRefs:\n    - name: productpage\n      port: 9080\n</code></pre> <p>It is worth calling out how the route binds to the Gateway through the <code>parentRefs</code> field, and that we bind specifically to the port 443 listener:  when a request arrives over HTTPS, the routing rules will match.  We expose various endpoints including the <code>productpage</code> web UI, access to static resources, the <code>/login</code> and <code>/logout</code> endpoints, and the <code>productpage</code> API.  The <code>backendRef</code> directs matching requests to the service running inside the cluster.</p> <p>The Gateway API offers many more controls over how requests get routed, including traffic splitting, request mirroring, support for timeouts and retries.  Istio has had its own resources for traffic management, namely the <code>VirtualService</code> resource, and today fully supports the Gateway API as the defacto standard.</p> <p>The same <code>HTTPRoute</code> (and other Route-type resources) is also used for configuring east-west traffic, as we will see shortly.</p>"},{"location":"ingress/#add-an-authorizationpolicy","title":"Add an AuthorizationPolicy","text":"<p>Istio allows us to overlay a security configuration as well.</p> <p>For example, we can define an AuthorizationPolicy to allow only the Ingress gateway to call the <code>productpage</code> service.</p> <pre><code>---\napiVersion: security.istio.io/v1\nkind: AuthorizationPolicy\nmetadata:\n name: allow-gateway-to-productpage\n namespace: bookinfo\nspec:\n selector:\n   matchLabels:\n     app: productpage\n action: ALLOW\n rules:\n - from:\n   - source:\n       principals:\n       - cluster.local/ns/common-infrastructure/sa/shared-gateway-istio\n</code></pre> <p>Above, note the SPIFFE identity of the Gateway <code>shared-gateway</code> is a function of its namespace and associated service account name.</p> <p>This authorization policy is not strictly an ingress-specific concern, as it applies to any requests targeting the <code>productpage</code> service.</p>"},{"location":"ingress/#test-ingress","title":"Test ingress","text":"<p>We can obtain the external IP address of the ingress gateway either by inspecting the Service resource <code>status</code> section.</p> <pre><code>kubectl get svc -n common-infrastructure shared-gateway-istio\n</code></pre> <pre><code>NAME                   TYPE           CLUSTER-IP     EXTERNAL-IP    PORT(S)                                      AGE\nshared-gateway-istio   LoadBalancer   10.43.94.151   192.168.97.2   15021:32006/TCP,80:31344/TCP,443:32559/TCP   175m\n</code></pre> <p>Or as an environment variable <code>GW_IP</code>:</p> <pre><code>export GW_IP=$(kubectl get svc -n common-infrastructure shared-gateway-istio -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\n</code></pre> <p>Alternatively, we can inspect the Gateway resource's <code>status</code> section:</p> <pre><code>kubectl get gtw -n common-infrastructure shared-gateway\n</code></pre> <pre><code>NAME             CLASS            ADDRESS        PROGRAMMED   AGE\nshared-gateway   istio            192.168.97.2   True         175m\n</code></pre> <p>Capture the IP address as an environment variable:</p> <pre><code>export GW_IP=$(kubectl get gtw -n common-infrastructure shared-gateway -o jsonpath='{.status.addresses[0].value}')\n</code></pre> <p>With DNS to resolve to that address, we should be able to simply send a <code>curl</code> request.</p> <p>Alternatively (without DNS configured), we can instruct <code>curl</code> to resolve the hostname to that IP address as follows:</p> <pre><code>curl -s --insecure https://bookinfo.example.com/productpage --resolve bookinfo.example.com:443:$GW_IP | grep title\n</code></pre> <p>The response is an HTML page, and the above command just looks for the page title (to limit the verboseness of the output):</p> <pre><code>&lt;title&gt;Simple Bookstore App&lt;/title&gt;\n</code></pre> <p>This is evidence that ingress is configured and functioning.</p>"},{"location":"ingress/#test-authorization","title":"Test authorization","text":"<p>Attempt to call <code>productpage</code> from the unauthorized <code>curl</code> client running in the <code>default</code> namespace:</p> <pre><code>kubectl exec deploy/curl -- curl -s productpage.bookinfo:9080/productpage\n</code></pre> <p>Response should indicate a terminated request:</p> <pre><code>command terminated with exit code 6\n</code></pre> <p>For the details, we can inspect the logs of the ztunnel component:</p> <pre><code>kubectl logs --follow -n istio-system -l app.kubernetes.io/name=ztunnel\n</code></pre> <p>The output in so many words indicates a \"401 Unauthorized\" response:</p> <pre><code>2025-06-30T06:41:34.685667Z     error   access  connection complete     src.addr=10.42.0.9:53890 src.workload=\"curl-5b549b49b8-sf5qz\" src.namespace=\"default\" src.identity=\"spiffe://cluster.local/ns/default/sa/curl\" dst.addr=10.42.0.17:15008 dst.hbone_addr=10.42.0.17:9080 dst.service=\"productpage.bookinfo.svc.cluster.local\" dst.workload=\"productpage-v1-78dfd4688c-rbm5g\" dst.namespace=\"bookinfo\" dst.identity=\"spiffe://cluster.local/ns/bookinfo/sa/bookinfo-productpage\" direction=\"inbound\" bytes_sent=0 bytes_recv=0 duration=\"0ms\" error=\"connection closed due to policy rejection: allow policies exist, but none allowed\"\n2025-06-30T06:41:34.685787Z     error   access  connection complete     src.addr=10.42.0.9:44984 src.workload=\"curl-5b549b49b8-sf5qz\" src.namespace=\"default\" src.identity=\"spiffe://cluster.local/ns/default/sa/curl\" dst.addr=10.42.0.17:15008 dst.hbone_addr=10.42.0.17:9080 dst.service=\"productpage.bookinfo.svc.cluster.local\" dst.workload=\"productpage-v1-78dfd4688c-rbm5g\" dst.namespace=\"bookinfo\" dst.identity=\"spiffe://cluster.local/ns/bookinfo/sa/bookinfo-productpage\" direction=\"outbound\" bytes_sent=0 bytes_recv=0 duration=\"0ms\" error=\"http status: 401 Unauthorized\"\n</code></pre>"},{"location":"ingress/#analysis-for-ingress","title":"Analysis for Ingress","text":"<p>Here is a general outline of the process we followed to configure ingress:</p> <ul> <li>Provision and configure the gateway with the <code>Gateway</code> resource</li> <li>Configure routing with the <code>HTTPRoute</code> (or a different protocol-specific route) resource</li> <li>Configure security policy</li> </ul> <p>Let us next look at how we might configure and control egress traffic, and see how the process resembles what we just did for ingress.</p>"},{"location":"mesh/","title":"Configure &amp; Control Mesh traffic","text":"<p>Back in setup, when you deployed the <code>bookinfo</code> sample application, you were instructed to label the <code>bookinfo</code> namespace:</p> <pre><code>kubectl label namespace bookinfo istio.io/dataplane-mode=ambient\n</code></pre> <p>That simple instruction was all that was required to make the workloads a part of the mesh. Unlike sidecar mode, with ambient mode workloads do not require a restart, because no sidecars need to be injected. The mesh concerns reside in a separate layer, and become a part of the underlying platform.</p> <p>It's important to understand and to highlight what it means exactly for a workload to be \"a part of the mesh.\" What happens behind the scenes?</p> <p>The following takes place implicitly, without requiring any configuration:</p> <ul> <li>Workloads are assigned cryptographic identities by the control plane (ztunnel maintains them on behalf of your workloads).</li> <li>The Istio CNI plugin reroutes the network communication in and out of each pod through the ztunnel layer 4 node proxies.</li> <li>The ztunnel proxies leverage those workload identities to encrypt all network communication between workloads using mutual TLS.</li> <li>The ztunnel proxies automatically produce and expose layer 4 telemetry: TCP bytes sent and received, TCP connections opened and closed.</li> </ul> <p>The mesh doesn't require any additional configuration, but it definitely has more to offer. We can:</p> <ul> <li>Layer on L4 authorization policies, restricting network communications based on workload identity</li> <li>Add L7 traffic management policies, leveraging higher level information for making routing decisions</li> <li>Add L7 authorization policies, again leveraging higher level information for making security-related decisions</li> <li>Add L7 telemetry</li> </ul> <p>All of those layer 7 capabilities rely on layer 7 proxies, which ambient mode allows us to provision on demand. Let us work through an example.</p>"},{"location":"mesh/#traffic-management-example","title":"Traffic Management Example","text":"<p>A canonical example of traffic management in the mesh is to configure traffic splitting, which is the basis for performing canary deployments and A/B tests.</p> <p>Note:  there may exist specific mesh features that were supported by Istio's original API that may still be considered experimental in the Gateway API.</p> <p>In this example we focus on the <code>reviews</code> service, for which three versions happen to be deployed: v1, v2, and v3.</p> <p>We begin by provisioning a waypoint.</p>"},{"location":"mesh/#provision-a-waypoint","title":"Provision a waypoint.","text":"<p>Traffic splitting, and the conditional routing of HTTP requests, perhaps based on specific headers in the request, are by definition a layer 7 concern, and so require that services be proxied by a layer 7 gateway.</p> <p>In Istio ambient mode, we called these internal gateways \"waypoints\"; the term \"micro gateway\" is often used to refer to them.</p> <p>As we already saw in the egress example, the Istio CLI provides a convenience command to provision a waypoint and optionally associate it to specific workloads.</p> <p>In this example, we provision the waypoint <code>bookinfo-proxy</code> and associate it to all workloads that reside in the <code>bookinfo</code> namespace:</p> <pre><code>istioctl waypoint apply --enroll-namespace --name bookinfo-proxy \\\n  --namespace bookinfo\n</code></pre> <p>The implication is that any request to any of the <code>bookinfo</code> services will be proxied by this newly-created waypoint.</p> <p>What the command actually does to \"enroll\" the namespace is to label it with the conventional label <code>istio.io/use-waypoint</code>, as indicated by the output of the above command:</p> <pre><code>\u2705 waypoint bookinfo/bookinfo-proxy applied\n\u2705 namespace bookinfo labeled with \"istio.io/use-waypoint: bookinfo-proxy\"\n</code></pre>"},{"location":"mesh/#setup","title":"Setup","text":"<p>In ambient mode, we are no longer required to define \"subsets\" - specific versions of a microservice - with a <code>DestinationRule</code>. We can simply use a Kubernetes <code>Service</code> definition with the right combination of selectors.</p> <p>Apply the following resource (which is bundled with the <code>bookinfo</code> sample app), which defines these \"sub\" services for <code>bookinfo</code>, among them <code>reviews-v1</code>, <code>reviews-v2</code>, and <code>reviews-v3</code>:</p> <pre><code>kubectl apply -n bookinfo \\\n  -f https://raw.githubusercontent.com/istio/istio/refs/heads/master/samples/bookinfo/platform/kube/bookinfo-versions.yaml\n</code></pre> <p>Now that we have specific services defined for each version of the <code>reviews</code> service, we can define HTTPRoutes that reference them.</p>"},{"location":"mesh/#configure-the-waypoint","title":"Configure the waypoint","text":"<p>Configure a traffic split whereby 50% of requests are routed to the service <code>reviews-v1</code> and 50% to <code>reviews-v2</code> (implying none to <code>reviews-v3</code>).</p> <p>The following <code>HTTPRoute</code> captures the configuration:</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: reviews-route\n  namespace: bookinfo\nspec:\n  parentRefs:\n  - group: \"\"\n    kind: Service\n    name: reviews\n    port: 9080\n  rules:\n  - backendRefs:\n    - name: reviews-v1\n      port: 9080\n      weight: 50\n    - name: reviews-v2\n      port: 9080\n      weight: 50\n</code></pre> <p>Above, the difference in configuration from the ingress routing example is the <code>parentRef</code> being of type Service -- previously it was a reference to a Gateway. By associating the route with a Service, we are basically configuring routing rules for any requests that target that service.</p> <p>Apply the route.</p> <p>Inspect the routes in the <code>bookinfo</code> namespace:</p> <pre><code>kubectl get httproute -n bookinfo\n</code></pre> <p>The output shows that we now have two routes, one applied at ingress, bound to the gateway, and the other the route that configures internal traffic to the <code>reviews</code> service:</p> <pre><code>NAME             HOSTNAMES                  AGE\nbookinfo-route   [\"bookinfo.example.com\"]   42m\nreviews-route                               4s\n</code></pre>"},{"location":"mesh/#test-it","title":"Test it","text":"<pre><code>for i in {1..10}; do\nkubectl exec deploy/curl -- curl -s reviews.bookinfo:9080/reviews/123 | jq | grep podname\ndone\n</code></pre> <p>Note in the output that responses are coming exclusively from instances of <code>reviews-v1</code> and <code>reviews-v2</code> services, with approximately a 50% split:</p> <pre><code>  \"podname\": \"reviews-v2-5c757d5846-b57dx\",\n  \"podname\": \"reviews-v1-849f9bc5d6-qs8nx\",\n  \"podname\": \"reviews-v1-849f9bc5d6-qs8nx\",\n  \"podname\": \"reviews-v2-5c757d5846-b57dx\",\n  \"podname\": \"reviews-v1-849f9bc5d6-qs8nx\",\n  \"podname\": \"reviews-v1-849f9bc5d6-qs8nx\",\n  \"podname\": \"reviews-v2-5c757d5846-b57dx\",\n  \"podname\": \"reviews-v2-5c757d5846-b57dx\",\n  \"podname\": \"reviews-v1-849f9bc5d6-qs8nx\",\n  \"podname\": \"reviews-v1-849f9bc5d6-qs8nx\",\n</code></pre> <p>We can proceed to configure other aspects of the mesh, such as adding an <code>AuthorizationPolicy</code> for calls to the <code>reviews</code> service, to control what workloads are permitted to interact with it.  The process would be similar to examples we've already seen for ingress and egress.</p>"},{"location":"mesh/#analysis","title":"Analysis","text":"<p>In this mesh example, we applied the same API, but to control internal traffic.</p> <p>The overall procedure was very similar to ingress and egress:</p> <ul> <li>Provision the gateway or waypoint.</li> <li>Associate the proxy with specific services (not applicable for the ingress use case).</li> <li>Define traffic policies (routing rules and others) such as HTTPRoutes and possibly DestinationRule's.</li> <li>Apply security policies such as AuthorizationPolicy resources.</li> </ul>"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#a-cluster-gateway-crds-and-istio","title":"A Cluster, Gateway CRDs, and Istio","text":"<p>Provision a Kubernetes cluster of your choosing. This could be a local kind cluster, or one running in your favorite cloud environment. My personal setup uses a local k3d cluster.</p> <pre><code>k3d cluster create my-cluster \\\n    --api-port 6443 \\\n    --k3s-arg \"--disable=traefik@server:0\" \\\n    --port 80:80@loadbalancer \\\n    --port 443:443@loadbalancer\n</code></pre> <p>Be sure to install the Kubernetes Gateway API CRDs:</p> <pre><code>kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.3.0/standard-install.yaml\n</code></pre> <p>Install Istio in ambient mode (I am using the stable version at time of writing, <code>1.26.2</code>):</p> <pre><code>istioctl install \\\n    --set profile=ambient \\\n    --set values.global.platform=k3d\n</code></pre>"},{"location":"setup/#provision-a-test-client","title":"Provision a test client","text":"<p>Deploy a test client in the form of a pod running a container with <code>curl</code> installed:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/istio/istio/refs/heads/master/samples/curl/curl.yaml\n</code></pre> <p>Make workloads in the <code>default</code> namespace a part of the mesh:</p> <pre><code>kubectl label namespace default istio.io/dataplane-mode=ambient\n</code></pre> <p>Note that the client workload does not require a sidecar in order to be part of the \"mesh\":</p> <pre><code>kubectl get pod -n default\n</code></pre> <p>We also no longer need to concern ourselves with restarting workloads.</p>"},{"location":"setup/#configure-access-logging","title":"Configure access logging","text":"<p>Enable access logging for Gateways and Waypoints by applying the following Telemetry resource:</p> <pre><code>---\napiVersion: telemetry.istio.io/v1\nkind: Telemetry\nmetadata:\n  name: enable-access-logging\n  namespace: istio-system\nspec:\n  accessLogging:\n    - providers:\n      - name: envoy\n</code></pre> <p>Above, we use the <code>istio-system</code> \"root\" namespace to ensure that the configuration applies to all workloads in the mesh (all namespaces).</p> <p>With setup out of the way, we begin by deploying a set of microservices to our cluster, and making them a part of the mesh.</p>"},{"location":"setup/#deploy-a-set-of-microservices","title":"Deploy a set of microservices","text":"<p>The canonical example used by the Istio project to represent a set of microservices is the <code>bookinfo</code> sample application. <code>bookinfo</code> consists of the following microservices, all running on the port <code>9080</code>: <code>productpage</code>, <code>details</code>, <code>reviews</code> and <code>ratings</code>.</p> <p>Begin by deploying these microservices to the Kubernetes cluster, in their own namespace, <code>bookinfo</code>:</p> <pre><code>kubectl create namespace bookinfo\n</code></pre> <pre><code>kubectl apply -n bookinfo \\\n  -f https://raw.githubusercontent.com/istio/istio/refs/heads/master/samples/bookinfo/platform/kube/bookinfo.yaml\n</code></pre> <p>Add all of the <code>bookinfo</code> workloads to the mesh, by labeling their namespace:</p> <pre><code>kubectl label namespace bookinfo istio.io/dataplane-mode=ambient\n</code></pre> <p>Let us start with controlling ingress traffic flows.</p>"},{"location":"summary/","title":"Summary","text":"<p>In this guide, we have seen how a single API can be used in Istio ambient mesh to configure ingress, egress, and mesh traffic.</p> <p>We configured a mesh to control ingress traffic, egress traffic, as well as mesh traffic.</p> <p>We can draw the following observations:</p> <ul> <li>The Kubernetes Gateway API becomes a standard, not just for configuring ingress, but for all traffic flows.</li> <li>We provision ingress gateways, waypoints, and egress gateways in similar ways, using the <code>Gateway</code> resource.     On-demand provisioning of gateways removes a major past pain point.</li> <li>We configure routing for both ingress and mesh traffic with the same <code>HTTPRoute</code> resource.  <code>HTTPRoute</code> offers a powerful API to control routing, with support for many route matching rules and expressions.     For fine-grained control over the mode of communication (protocols, encryption, etc..) we use for specific target workloads, we use a <code>DestinationRule</code>.</li> <li>Authorization is configured with the <code>AuthorizationPolicy</code> resource.     When Layer 7 authorization is required, we configure a waypoint to proxy the services in question.</li> </ul> <p>There is more to the story.  Istio ambient mesh:</p> <ul> <li>makes it easy to integrate third-party API gateways with mesh workloads.</li> <li>supports the notion of pluggable waypoints - bringing your own layer 7 proxy to configure aspects of the mesh, opening the door for additional capabilities such as rate limiting and request transformations.</li> </ul>"}]}